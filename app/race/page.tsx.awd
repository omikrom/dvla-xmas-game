"use client";

import { Canvas } from "@react-three/fiber";
import { Environment, OrbitControls } from "@react-three/drei";
import { Physics } from "@react-three/rapier";
import { useCallback, useEffect, useRef, useState } from "react";

import type { PlayerCar, TimerState, DeliveryItem, PowerUpItem } from "./types";

import { clamp, describeScoreBurst } from "./utils";
import useKeyboardControls, { keys } from "./hooks/useKeyboardControls";
import ScoreBursts from "./components/ScoreBursts";
import CountdownOverlay from "./components/CountdownOverlay";
import InfoModal from "./components/InfoModal";
import CameraAspectUpdater from "./components/CameraAspectUpdater";
import InterpolatedCar from "./components/InterpolatedCar";
import FollowCamera from "./components/FollowCamera";
import DebugPanel from "./components/DebugPanel";
import MobileControls from "./components/MobileControls";
import usePowerUps from "./hooks/usePowerUps";
import useInitializePowerUps from "./hooks/useInitializePowerUps";
import usePowerupVisuals from "./hooks/usePowerupVisuals";
import { POWERUP_CONFIGS } from "./types/powerup";

import DVLABuilding from "./assets/DVLABuilding";
import { DestructibleField } from "./assets/scenery/DestructibleField";
import { DeliveryDropZones, DeliveryTokens } from "./assets/DeliveryMarkers";
import { CarModel } from "./assets/Car";
import PowerUp from "./assets/PowerUp";
import useJoystick from "./hooks/useJoystick";
import LocalPowerUp from "./components/LocalPowerUp";
import CollisionEffects from "./components/CollisionEffects";
import Leaderboard from "./components/Leaderboard";
import MatchEvents from "./components/MatchEvents";
import DeliveryHUD from "./components/DeliveryHUD";
import {
  DeliveryPointersHelper,
  DeliveryPointersOverlay,
} from "./components/DeliveryPointers";

export default function Page2() {
  return <RaceClient />;
}

function RaceClient() {
  const [cars, setCars] = useState<PlayerCar[]>([]);
  const [timerState, setTimerState] = useState<TimerState | null>(null);
  const [deliveries, setDeliveries] = useState<DeliveryItem[]>([]);
  const [powerUps, setPowerUps] = useState<PowerUpItem[]>([]);
  const [renderedPowerUps, setRenderedPowerUps] = useState<PowerUpItem[]>([]);
  const [activePowerUps, setActivePowerUps] = useState<any[]>([]);
  const [destructibles, setDestructibles] = useState<any[]>([]);
  const prevDestructiblesRef = useRef<Map<string, boolean>>(new Map());
  const [matchEvents, setMatchEvents] = useState<
    Array<{ id: string; ts: number; msg: string }>
  >([]);
  const [infoOpen, setInfoOpen] = useState(false);
  const [name, setName] = useState<string>("");
  const [playerId, setPlayerId] = useState<string>("");
  const [collectedNotification, setCollectedNotification] = useState<{
    msg: string;
    ts: number;
  } | null>(null);
  const [collisionEffects, setCollisionEffects] = useState<any[]>([]);
  const [pointers, setPointers] = useState<any[]>([]);
  const canvasWrapRef = useRef<HTMLDivElement | null>(null);
  const interpolatedPositionsRef = useRef<Map<string, { x: number; y: number }>>(new Map());

  const [bursts, setBursts] = useState<
    { id: string; amount: number; message: string; createdAt: number }[]
  >([]);
  const [debugLogs, setDebugLogs] = useState<
    Array<{ id: string; ts: number; level: string; msg: string }>
  >([]);
  const [debugVisible, setDebugVisible] = useState<boolean>(true);

  const joystickValueRef = useRef({ x: 0, y: 0 });
  const {
    joystickBaseRef,
    joystick,
    isMobile,
    acceleratorHeld,
    brakeHeld,
    setAcceleratorHeld,
    setBrakeHeld,
    handleJoystickPointerDown,
    handleJoystickPointerMove,
    handleJoystickPointerEnd,
  } = useJoystick();

  useKeyboardControls();

  const pushDebug = useCallback(
    (msg: string, level: "info" | "warn" | "error" = "info") => {
      const entry = {
        id: `d-${Date.now()}-${Math.random().toString(36).slice(2, 6)}`,
        ts: Date.now(),
        level,
        msg,
      };
      setDebugLogs((d) => [entry, ...d].slice(0, 200));
      if (level === "error") console.error(msg);
    },
    []
  );

  // Wire server-authoritative powerup handling and visuals
  usePowerUps({
    playerId,
    cars,
    powerUps,
    setPowerUps,
    setActivePowerUps,
    setCars,
    setCollectedNotification,
    pushDebug,
    setCollisionEffects,
  });

  // Initialize powerups when race begins (timerState presence => racing)
  useInitializePowerUps({
    gameState: timerState ? "racing" : "lobby",
    deliveries,
    powerUps,
    setPowerUps,
  });

  // Drive visuals for powerup pickups
  usePowerupVisuals({ powerUps, setCollisionEffects, pushDebug });

  useEffect(() => {
    if (playerId) return;
    if (typeof window === "undefined") return;
    const stored =
      sessionStorage.getItem("playerId") ||
      `player-${Math.random().toString(36).slice(2, 10)}`;
    sessionStorage.setItem("playerId", stored);
    setPlayerId(stored);
    const params = new URLSearchParams(window.location.search);
    setName(params.get("name") || `Player-${Math.floor(Math.random() * 1000)}`);
  }, [playerId]);

  useEffect(() => {
    if (!collectedNotification) return;
    const t = setTimeout(() => setCollectedNotification(null), 2500);
    return () => clearTimeout(t);
  }, [collectedNotification]);

  // Prune old collision effects after a short lifetime
  useEffect(() => {
    const iv = setInterval(() => {
      setCollisionEffects((prev) =>
        prev.filter((fx) => Date.now() - (fx.timestamp || 0) < 1600)
      );
    }, 600);
    return () => clearInterval(iv);
  }, []);

  // Reflect joystick values into joystickValueRef for the game loop
  useEffect(() => {
    joystickValueRef.current.x = joystick.x;
    joystickValueRef.current.y = joystick.y;
  }, [joystick.x, joystick.y]);

  // Keep a local rendered list so we can animate removal locally
  useEffect(() => {
    setRenderedPowerUps((prev) => {
      const byId = new Map(prev.map((p) => [p.id, p]));
      for (const pu of powerUps) {
        byId.set(pu.id, pu);
      }
      return Array.from(byId.values());
    });
  }, [powerUps]);

  // Detect destructible state changes and spawn collision effects when destroyed
  useEffect(() => {
    const prevMap = prevDestructiblesRef.current;
    for (const d of destructibles) {
      const prevDestroyed = prevMap.get(d.id) || false;
      if (!prevDestroyed && d.destroyed) {
        // spawn collision effect
        setCollisionEffects((prev) => [
          ...prev,
          {
            id: `des-${d.id}-${Date.now()}`,
            position: [d.x, 0.6, d.y],
            timestamp: Date.now(),
            color: "#f97316",
          },
        ]);
        pushDebug(`Destructible destroyed: ${d.id}`);
        setMatchEvents((me) => [
          ...me,
          {
            id: `e-${Date.now()}-${d.id}`,
            ts: Date.now(),
            msg: `Destructible ${d.id} destroyed`,
          },
        ]);
        // generate debris client-side if server didn't include debris
        if (!d.debris || d.debris.length === 0) {
          const pieces = Math.max(4, Math.min(16, Math.floor(d.radius || 4)));
          const debris = Array.from({ length: pieces }).map((_, i) => {
            const ox = (Math.random() - 0.5) * (d.radius || 4);
            const oz = (Math.random() - 0.5) * (d.radius || 4);
            return {
              id: `local-debris-${d.id}-${Date.now()}-${i}`,
              x: d.x + ox,
              y: d.y + oz,
              z: 0.6 + Math.random() * 0.6,
              vx: (Math.random() - 0.5) * 6,
              vy: Math.random() * 5 + 2,
              vz: (Math.random() - 0.5) * 6,
              size: Math.max(
                0.25,
                (d.radius || 2) * (Math.random() * 0.6 + 0.2)
              ),
              color: d.color || (Math.random() > 0.5 ? "#8B4513" : "#4B5563"),
            };
          });
          // attach debris to the destructible locally
          setDestructibles((prev) =>
            prev.map((pd) => (pd.id === d.id ? { ...pd, debris } : pd))
          );
        }
      }
      prevMap.set(d.id, !!d.destroyed);
    }
    prevDestructiblesRef.current = prevMap;
  }, [destructibles, pushDebug]);

  // LocalPowerUp component is provided by ./components/LocalPowerUp

  const enqueueScoreBurst = useCallback((amount: number) => {
    if (amount <= 0) return;
    const id = `${Date.now()}-${Math.random().toString(36).slice(2, 6)}`;
    const message = describeScoreBurst(amount);
    const createdAt = Date.now();
    setBursts((b) => [...b, { id, amount, message, createdAt }]);
    setTimeout(() => setBursts((b) => b.filter((x) => x.id !== id)), 2000);
  }, []);

  // Simple game loop: POST steer/throttle to server and sync state
  useEffect(() => {
    if (!playerId) return;
    const t = setInterval(async () => {
      try {
        const keyboardSteer =
          (keys.ArrowLeft || keys.a ? 1 : 0) +
          (keys.ArrowRight || keys.d ? -1 : 0);
        const keyboardThrottle =
          (keys.ArrowUp || keys.w ? 1 : 0) +
          (keys.ArrowDown || keys.s ? -0.5 : 0);
        const joystickThrottle = acceleratorHeld
          ? 1
          : brakeHeld
          ? -0.5
          : -joystickValueRef.current.y;
        const steer = clamp(keyboardSteer + joystickValueRef.current.x);
        const throttle = clamp(keyboardThrottle + joystickThrottle);

        const res = await fetch("/api/game", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ playerId, name, steer, throttle }),
        });
        if (!res.ok) return;
        const data = await res.json();
        setCars(data.players || []);
        setTimerState(data.timer || null);
        setDeliveries(data.deliveries || []);
        setDestructibles(data.destructibles || []);
        setPowerUps(data.powerUps || []);
        setActivePowerUps(data.activePowerUps || []);
        setMatchEvents(data.events || []);

        // If server reports a score for me, show a burst (simple heuristic)
        const me = (data.players || []).find((p: any) => p.id === playerId);
        if (me && typeof me.score === "number")
          enqueueScoreBurst(Math.max(0, Math.round(me.score)));
      } catch (err) {
        pushDebug(String(err), "warn");
      }
    }, 250);
    return () => clearInterval(t);
  }, [
    playerId,
    name,
    enqueueScoreBurst,
    pushDebug,
    acceleratorHeld,
    brakeHeld,
  ]);

  const myCar = cars.find((c) => c.id === playerId) ?? null;

  return (
    <main className="h-screen w-screen bg-slate-900 text-white">
      <ScoreBursts bursts={bursts} />
      <CountdownOverlay
        showCountdown={false}
        showGoSignal={false}
        countdownNumber={null}
        trafficActiveIndex={-1}
      />

      <div className="absolute inset-0" ref={canvasWrapRef}>
        <Canvas shadows camera={{ position: [0, 40, 60], fov: 65 }}>
          <CameraAspectUpdater width={800} height={600} />
          <ambientLight intensity={0.8} />
          <Environment preset="sunset" />
          <Physics gravity={[0, -9.81, 0]}>
            <DVLABuilding />
            <DestructibleField destructibles={[]} />
            <DeliveryDropZones deliveries={deliveries} />
            <DeliveryTokens
              deliveries={deliveries}
              carrierElevations={{}}
              interpolatedPositionsRef={interpolatedPositionsRef}
            />

            {cars.map((car) => (
              <InterpolatedCar
                key={car.id}
                car={car}
                positionsRef={interpolatedPositionsRef}
              >
                <CarModel
                  bodyColor={car.color || "#ef4444"}
                  trimColor="#111827"
                />
              </InterpolatedCar>
            ))}

            {/* PowerUp items in the world (renderedPowerUps allows local visuals/removal) */}
            {renderedPowerUps.map((pu) => (
              <LocalPowerUp
                key={pu.id}
                pu={pu}
                onRemoved={(id) =>
                  setRenderedPowerUps((prev) => prev.filter((x) => x.id !== id))
                }
              />
            ))}

            {/* Collision effects (rendered by component) */}
            <CollisionEffects
              effects={collisionEffects}
              setEffects={setCollisionEffects}
            />
            {/* Compute pointer positions for deliveries (updates overlay) */}
            <DeliveryPointersHelper
              deliveries={deliveries}
              onUpdate={(p) => setPointers(p)}
            />
          </Physics>
          <OrbitControls />
          {myCar && <FollowCamera playerId={playerId} cars={cars} />}
        </Canvas>
        {/* Overlay arrows that point to delivery targets */}
        <DeliveryPointersOverlay pointers={pointers} />
      </div>

      <div className="absolute top-4 left-4 z-40">
        <button
          onClick={() => setDebugVisible((v) => !v)}
          className="px-3 py-1 bg-white/10 rounded"
        >
          Toggle Debug
        </button>
        <button
          onClick={() => setInfoOpen((s) => !s)}
          className="ml-2 px-3 py-1 bg-white/10 rounded"
        >
          Info
        </button>
      </div>

      <InfoModal
        open={infoOpen}
        onClose={() => setInfoOpen(false)}
        name={name}
        powerupConfigs={POWERUP_CONFIGS as any}
        formattedTimer={
          timerState
            ? `${Math.max(
                0,
                Math.floor((timerState.timeRemainingMs || 0) / 1000)
              )}`
            : "--:--"
        }
        timerProgress={0}
        waitingDeliveries={
          deliveries.filter((d) => d.state === "waiting").length
        }
        deliveries={deliveries}
        destroyedObjects={destructibles.filter((d: any) => d.destroyed).length}
        totalDestructibles={destructibles.length}
        myCar={myCar as any}
        activePowerUps={activePowerUps}
        leaderboard={cars.map((c) => ({
          id: c.id,
          name: c.name,
          score: Math.round(c.score || 0),
          color: c.color,
        }))}
        recentEvents={matchEvents}
      />

      <Leaderboard
        entries={cars.map((c) => ({
          id: c.id,
          name: c.name,
          score: Math.round(c.score || 0),
          color: c.color,
        }))}
      />
      <MatchEvents events={matchEvents} />
      <DeliveryHUD
        waitingCount={deliveries.filter((d) => d.state === "waiting").length}
        carrying={
          myCar?.carryingDeliveryId
            ? deliveries.find((d) => d.id === myCar?.carryingDeliveryId)
            : undefined
        }
        deliveries={deliveries}
      />

      {collectedNotification && (
        <div className="absolute top-4 right-4 z-50">
          <div className="px-3 py-2 bg-emerald-600/90 rounded text-white text-sm">
            {collectedNotification.msg}
          </div>
        </div>
      )}

      <DebugPanel
        debugLogs={debugLogs}
        onClear={() => setDebugLogs([])}
        visible={debugVisible}
      />
      <MobileControls
        isMobile={isMobile}
        joystickBaseRef={joystickBaseRef}
        joystick={joystick}
        onPointerDown={handleJoystickPointerDown}
        onPointerMove={handleJoystickPointerMove}
        onPointerEnd={handleJoystickPointerEnd}
        acceleratorHeld={acceleratorHeld}
        brakeHeld={brakeHeld}
        setAcceleratorHeld={setAcceleratorHeld}
        setBrakeHeld={setBrakeHeld}
      />
    </main>
  );
}
